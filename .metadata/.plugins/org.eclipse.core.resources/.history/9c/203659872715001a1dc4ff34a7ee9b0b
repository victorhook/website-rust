package inl3;

import java.awt.Color;
import java.util.Arrays;

public class Generator {
	
	private final Color WHITE = Color.white, BLACK = Color.black;
	private final int VERY_LOW = 128, LOW = 256, MEDIUM = 512, HIGH = 1024, VERY_HIGH = 2048;
	private final float RED = 0, YELLOW = 1/6, GREEN = 2/6, CYAN = 3/6, BLUE = 4/6, MAGNETA = 5/6;
	private final float[] COLOR_NUANCES = {RED, YELLOW, GREEN, CYAN, BLUE, MAGNETA};
	private final int COLOR_RESOLUTION = 50;
	
	private Color[] red, yellow, green, cyan, blue, magneta, selectedColors;
	private Color[][] colors;
	
	private boolean colorSelected;
	
	public Generator() {
		// Skapar tre olika färgkartor som kan användas om användaren vill rita med färg

		colors = new Color[7][COLOR_RESOLUTION];
		for (int color = 0; color < colors.length; color++) {
			colors[color] = makeColors(COLOR_NUANCES[color], COLOR_RESOLUTION);
		}

	}
	
	
	/** Ritar en bild i fönstret i användargränssnittet gui */
	public void render(MandelbrotGUI gui) {
		
		gui.disableInput();
		Complex[][] complex = mesh(gui.getMinimumReal(), gui.getMaximumReal(), gui.getMinimumImag(),
					               gui.getMaximumImag(), gui.getWidth(), gui.getHeight());
		
		String iterationText = gui.getIterationText();
		String colorScaleText = gui.getColorScaleText();
		
		if (gui.getMode() == gui.MODE_COLOR) {					// Användaren vill använda färg
			colorSelected = true;								// Om ingen färg är vald, blir default svart
		}
		selectedColors = findColor(colorScaleText);				// Väljer rätt färg utifrån vad användaren ville ha (Default är röd)

		// Antal iteration som ska göras vid varje beräkning
		int iterations = (iterationText.length() > 0) ? Integer.valueOf(iterationText) 
													  : Mandelbrot.MANTELBROT_ITERATIONS;
		
		
		int resolution = adjustResolution(gui.getResolution());
		int resolutionX = gui.getWidth() / resolution;			// Hur många iterationssteg som ska göra i WIDTH (x-led)
		int resolutionY = gui.getHeight() / resolution;			// Hur många iterationssteg som ska göra i HEIGHT (y-led)
		int padding = resolution - 1;							// Anger hur stora steg som ska göras mellan varje indexering i complex[][]

		
		Color[][] picture = new Color[resolutionY][resolutionX];// Skapar en bild som ska användas för att rita
	
		int row = 0, col;										// Används för att indexera picture-vektorn
		int rowIndex = padding / 2, colIndex;					// Används för att indexera complex-vektorn
		double re, im;											// Används endast för del 1, då jag ritade cirklar

		int divergeAmmount;										// Används för att ange hur mycket mandelbrottsmängden divergerar
		
		
		while (row < resolutionY) {								// Huvudloopen för beräkningarna
			
			col = 0;
			colIndex = padding / 2;
			
			while (col < resolutionX) {


				if (colorSelected) {
					// Nuvarande komplext tal      Antal iterationer
					divergeAmmount = calculateMandelbrotColor(complex[rowIndex][colIndex], iterations);
					picture[row][col] = colorss[divergeAmmount];		// Målar med färg
				} else {
					if (calculateMandelbrotBW(complex[rowIndex][colIndex], iterations)) {
						picture[row][col] = BLACK;
					} else {
						picture[row][col] = WHITE;
					}				
				}
				
				colIndex += padding + 1;
				col++;
			}
			System.out.println();
			rowIndex += padding + 1;
			row++;
			
		}
		
		gui.putData(picture, resolution, resolution);
		gui.enableInput();
		
	}

	private boolean calculateMandelbrotBW(Complex c, int iterations) {

		Complex z = new Complex(0,0);
		int counter = 0;
		
		while (counter < iterations && z.getAbs2() <= 4) {
			z.mul(z);
			z.add(c);
			counter++;
		}
	
	  return counter >= iterations;
	}
	
	/** Beräknar en följ av komplexa tal med Mandelbrotformeln */
	private int calculateMandelbrotColor(Complex c, int iterations) {
		
		Complex z = new Complex(0,0);
		int counter = 0;
		
		while (counter < iterations && z.getAbs2() <= Integer.MAX_VALUE) {
			z.mul(z);
			z.add(c);
			counter++;
		}
		
		return counter % 50;
		//return counter == 0 ? TOTAL_COLORS - 1 : (TOTAL_COLORS - 1) - (TOTAL_COLORS - 1) * (counter / iterations);
		
			//   Värde mellan 0.0-1.0 * 255 (MAX-värdet på färgskalan)
		//return (counter / iterations) * 254;		// Hur pass mycket talet divergerat
		
		/*
		  Avkommentera för den första versionen då endast svart och vit användes
		  return counter >= Mandelbrot.MANTELBROT_ITERATIONS;
		 */
	}
	

	/** Skapar en matrix där varje element är ett komplext tal som 
	 * har rätt koordinater */
	private Complex[][] mesh(double minRe, double maxRe, double minIm, 
							 double maxIm, int width, int height) {
		
		Complex[][] matrice = new Complex[height][width];
		double stepSizeRe = Math.abs(maxRe - minRe) / width;
		double stepSizeIm = Math.abs(maxIm - minIm) / height;
		
		for (int row = 0; row < height; row++) {
			
			for (int col = 0; col < width; col++) {

				matrice[row][col] = new Complex( minRe + (col * stepSizeRe),
												 maxIm - (row * stepSizeIm) );						
			}
			
		}
		return matrice;
	}
	
	/** Justerar upplösningsvärdet för att kunna göra korrekta beräkningar vid
	 * såväl iterationerna som "stepsize" vid genomgång av matrisen. */
	private int adjustResolution(int resolution) {
		switch (resolution) {
		case VERY_HIGH:
			resolution = 1;
			break;
		case HIGH:
			resolution = 3;
			break;
		case MEDIUM:
			resolution = 5;
			break;
		case LOW:
			resolution = 7;
			break;
		case VERY_LOW:
			resolution = 9;
			break;
		}
		return resolution;
	}
	
	/** Väljer rätt färg utifrån vad användaren har valt. Röd är default */
	private Color[] findColor(String color) {
		if (color.toLowerCase().startsWith("b")) {
			return colors[BLUE];
		} else if (color.toLowerCase().startsWith("g")) {
			return colors[GREEN];
		} else {
			return colors[RED];
		}
	}
	
	private Color[] makeColors(float color, int colorResolution) {
	   
		Color[] colors = new Color[colorResolution];
        for (float i = 0; i < colorResolution; i++) {
    	   colors[(int) i] = Color.getHSBColor(color, 1f, i / colorResolution);
        }
		
		return colors;
	}
	
	/** Genererar en färgkarta med alla färgerna i olika skalor */
	private Color[] generateColors(Color[] colors, int color) {
		
			int index = 0;
			
			while (index < TOTAL_COLORS) {
				switch (color) {
				case GREEN:
 				   colors[index++] = new Color(0, index*COLOR_RESOLUTION, 0);				// Grön färgskala
		       	   break;
	       	   case BLUE:
	       		   colors[index++] = new Color(0, 0, index*COLOR_RESOLUTION);				// Blå färgskala
	       		   break;
       		   default:
       			   colors[index++] = new Color(index*COLOR_RESOLUTION, 0, 0);				// Röd färgskala
				}
			}

	       return colors;
	}
	
}
